# python
"""
This dump file is used to parse the lx module from Modo. This module is not the typical python
module due to it being dynamically create during the load time of Modo. There for we can only
extract it in it's "live" context. This scripts is used to parse the lx module from within Modo.

The modo-api repo handles launching Modo and running this script af a fire-and-forget script. And
thus important to keep everything needed to run this script contained in this single python file.

"""
import inspect
import re
import lx
import shutil
from pathlib import Path

BASE_DIR = Path(lx.args()[0][1:-1])
PYTHON_DIR = Path(lx.args()[1][1:] + " " + lx.args()[2][:-1])
ROOT_DIR = BASE_DIR.parent.parent.parent
PLATFORM = lx.service.Platform()
MODO_VERSION = (f"{PLATFORM.AppVersionMajor()}."
                f"{PLATFORM.AppVersionMinor()}."
                f"{PLATFORM.AppVersionSP()}")
MODO_BUILD = ": ".join((MODO_VERSION, str(PLATFORM.AppBuild())))
LX_DIR = ROOT_DIR / "lx"
if not LX_DIR.exists():
    LX_DIR.mkdir()


class_data = \
    """

class {name}:
    \"\"\"{doc}\"\"\"
    def __init__(self{cast}):
        pass
{routines}
"""
method_data = \
    """
    def {name}(self{arguments}):
        \"\"\"{doc}
        {args}
        Returns:
            {returns}
        \"\"\"
        pass"""
arg_docs = "\n        Args:\n"
arg_data = "            {arg} ({type}):\n"
HEADER = f"\"\"\"Autogenerated by Shawn Frueh\nModo {MODO_BUILD}\n\"\"\"\n"
value_types = {"item": "lxu.object.Item", "source": "lxu.object.Item", "image": "lx.object.Image",
               "unknown": "lxu.object.Unknown", "destination": "lxu.object.Item",
               "group": "lxu.object.Item", "matrix": "lx.object.Matrix", "vector": "tuple",
               "notifier": "lx.object.Notifier", "string": "str", "integer": "int",
               "float": "float", "boolean": "bool", "pointer": "int", "mesh": "lxu.object.Mesh"}


def parse_type(type_pair, as_arg=False):
    """Formats a long name into it's known data type.

    Args:
        type_pair (list[str]):
        as_arg (bool): If True, will format the pair into an argument string "name (value):"
    """
    arg_type, arg_name = type_pair
    # If object is the first item
    if arg_type.lower() == "object":
        arg_value = value_types.get(arg_name.lower(), None)
        if arg_value:
            arg_type, arg_name = arg_value, arg_type
        else:
            # If no value, swap: object, valItem -> val, object
            arg_type, arg_name = arg_name, arg_type
    # If object is the second item
    elif arg_name.lower() == "object":
        arg_value = value_types.get(arg_type.lower(), None)
        if arg_value:
            arg_name, arg_type = arg_name, arg_value
    # If no object then just use type
    else:
        arg_type = value_types.get(arg_type, arg_type)

    if as_arg:
        return f"{arg_name} ({arg_type}):"
    return arg_type


def parse_routine_doc(name, doc):
    """Formats the routines docstring.

    Args:
        name (str): The name of the routine.
        doc (str): The raw docstring.

    Returns:
        method_data (str): Formatted
    """
    # if '=' is in the string the return data in on the left.
    return_val = doc.split("=")[0].strip() if "=" in doc else "None"
    if len(return_val.split(" ")) == 2:
        # If there is a space we have a type/name pair: 'object item'
        return_val = parse_type(return_val.split(" "), as_arg=True)
    else:
        # If there is no pair see if we can format the return type: 'integer' -> 'int'
        return_val = value_types.get(return_val, return_val)
    # If '=' in the string the example is on the right: 'integer = get(object item, pointer packet)'
    method_args = doc.split("=")[1] if "=" in doc else (doc if name in doc else None)
    arg_doc_string = ""
    arg_names = []
    if method_args:
        # Extract the data: 'get(object item, pointer packet)' -> 'object item, pointer packet'
        match = re.search(r"\(([^)]*)\)", method_args)
        if match and match.group(1) != "":
            # Extract arguments: 'object item, pointer packet' -> ['object item', 'pointer packet']
            arg_list = match.group(1).split(",")
            arg_doc_string = arg_docs
            # Format each argument
            for arg in arg_list:
                arg_info = arg.split(" ")
                if len(arg_info) == 2:
                    arg_names.append(arg_info[1])
                    # Add the formatted argument: 'pointer packet' -> 'packet (int)'
                    arg_doc_string += arg_data.format(arg=arg_info[1], type=parse_type(arg_info))
    # If we found arguments, format them for the definition.
    if len(arg_names):
        arg_names = ", " + ", ".join(arg_names)
    else:
        arg_names = ""
    # Return the formatted routine docstring
    return method_data.format(name=name, doc=doc, args=arg_doc_string, returns=return_val,
                              arguments=arg_names)


def parse_routines(routine_class):
    """Iterate and format all routines from the given class

    Args:
        routine_class (object): The object to inspects routines from.

    Returns:
        str: Formatted routine.
    """
    formatted_routines = []
    # Iterate over each routine of the given class.
    for routine_name, routine_obj in inspect.getmembers(routine_class, inspect.isroutine):
        # Only get non protected routines
        if not routine_name.startswith("__"):
            docs = inspect.getdoc(routine_obj)
            formatted_routines.append(parse_routine_doc(routine_name, docs))
    return "\n".join(formatted_routines)


# TODO: Safely handle the init
# init_file = LX_DIR / "__init__.py"
# with init_file.open("w+") as dump_file:
#    data = [HEADER]
#    data_app = data.append
#    for mod in inspect.getmembers(lx):
#        mod.t
#    for class_name, class_obj in inspect.getmembers(method, inspect.isclass):
#        # Get the methods of the class and format them.
#        routines = parse_routines(class_obj)
#        # Get the class docstrings
#        class_docs = inspect.getdoc(class_obj)
#        # If no class docstrings just pass in the class name.
#        doc_strings = class_docs if class_docs else class_name
#        # Format class object.
#        cast = ", unknown=None" if method == lx.object else ""
#        class_doc = class_data.format(name=class_name, doc=doc_strings, routines=routines,
#                                      cast=cast)
#        data_app(class_doc)

# Generate Object and service classes
for method in (lx.object, lx.service):
    method_file = LX_DIR / f"{method.__name__}.py"
    # Parse method members and then export.
    with method_file.open("w+") as dump_file:
        data = [HEADER]
        data_app = data.append
        for class_name, class_obj in inspect.getmembers(method, inspect.isclass):
            # Get the methods of the class and format them.
            routines = parse_routines(class_obj)
            # Get the class docstrings
            class_docs = inspect.getdoc(class_obj)
            # If no class docstrings just pass in the class name.
            doc_strings = class_docs if class_docs else class_name
            # Format class object.
            cast = ", unknown=None" if method == lx.object else ""
            class_doc = class_data.format(name=class_name, doc=doc_strings, routines=routines,
                                          cast=cast)
            data_app(class_doc)
        # Write the data to the file
        dump_file.writelines(data)

# Generate result and symbol values
for method in (lx.result, lx.symbol):
    # Generate file path to write to
    method_file = LX_DIR / f"{method.__name__}.py"
    # Parse method members and then export.
    with method_file.open("w+") as dump_file:
        data = [HEADER + "\n"]
        data_app = data.append
        for item in dir(method):
            if not item.startswith("__"):
                data_app(f"{item} = {repr(getattr(method, item))}\n")
        # Write the data to the file
        dump_file.writelines(data)

# Copy the rest of the API directly from the install
# Copy lxu and modo directories locally.
for api_dir in ("lxu", "modo"):
    api_source = PYTHON_DIR / api_dir
    api_dest = ROOT_DIR / api_dir
    if api_source.is_dir():
        if api_dest.exists():
            shutil.rmtree(api_dest)
        shutil.copytree(api_source, api_dest, ignore=shutil.ignore_patterns("*.pyc"))

# Copy lxifc and lxsrv into an __init__ file.
for api_file in ("lxifc.py", "lxserv.py", "lxguid.py"):
    api_dest = ROOT_DIR / api_file.rstrip(".py") / "__init__.py"
    if not api_dest.parent.exists():
        api_dest.parent.mkdir()
    api_source = PYTHON_DIR / api_file
    data = ""

    # Extract the contents of the file.
    with api_source.open("r") as source_file:
        data = source_file.read()

    # write it into the __init__ file.
    with api_dest.open("w+") as dest_file:
        dest_file.write(data)

# Set the modo api version
version_line = f'__version__ = "{MODO_VERSION}"'
modo_init = ROOT_DIR / "modo" / "__init__.py"
# Get the data from __init__
with modo_init.open("r") as modo_file:
    modo_data = modo_file.read()

# Replace the line that contains __version__
modo_data = re.sub("__version__.*", version_line, modo_data)

# Write the update to the __init__
with modo_init.open("w+") as modo_file:
    modo_file.write(modo_data)
